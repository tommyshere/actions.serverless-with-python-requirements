"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const globals_1 = require("../globals");
const utils_1 = require("../utils");
class Route53Wrapper {
    constructor(profile, region) {
        let credentials = globals_1.default.serverless.providers.aws.getCredentials();
        credentials.region = globals_1.default.serverless.providers.aws.getRegion();
        credentials.httpOptions = globals_1.default.serverless.providers.aws.sdk.config.httpOptions;
        if (profile) {
            credentials = {
                credentials: new globals_1.default.serverless.providers.aws.sdk.SharedIniFileCredentials({
                    profile
                }),
                region: region || credentials.region,
                httpOptions: credentials.httpOptions
            };
        }
        this.route53 = new globals_1.default.serverless.providers.aws.sdk.Route53(credentials);
    }
    /**
     * Change A Alias record through Route53 based on given action
     * @param action: String descriptor of change to be made. Valid actions are ['UPSERT', 'DELETE']
     * @param domain: DomainInfo object containing info about custom domain
     */
    changeResourceRecordSet(action, domain) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (domain.createRoute53Record === false) {
                globals_1.default.logInfo(`Skipping ${action === "DELETE" ? "removal" : "creation"} of Route53 record.`);
                return;
            }
            // Set up parameters
            const route53HostedZoneId = yield this.getRoute53HostedZoneId(domain, domain.hostedZonePrivate);
            const route53Params = domain.route53Params;
            const route53healthCheck = route53Params.healthCheckId ? { HealthCheckId: route53Params.healthCheckId } : {};
            const domainInfo = (_a = domain.domainInfo) !== null && _a !== void 0 ? _a : {
                domainName: domain.givenDomainName,
                hostedZoneId: route53HostedZoneId,
            };
            let routingOptions = {};
            if (route53Params.routingPolicy === globals_1.default.routingPolicies.latency) {
                routingOptions = Object.assign({ Region: this.route53.config.region, SetIdentifier: (_b = domain.route53Params.setIdentifier) !== null && _b !== void 0 ? _b : domainInfo.domainName }, route53healthCheck);
            }
            if (route53Params.routingPolicy === globals_1.default.routingPolicies.weighted) {
                routingOptions = Object.assign({ Weight: domain.route53Params.weight, SetIdentifier: (_c = domain.route53Params.setIdentifier) !== null && _c !== void 0 ? _c : domainInfo.domainName }, route53healthCheck);
            }
            let hostedZoneIds;
            if (domain.splitHorizonDns) {
                hostedZoneIds = yield Promise.all([
                    this.getRoute53HostedZoneId(domain, false),
                    this.getRoute53HostedZoneId(domain, true),
                ]);
            }
            else {
                hostedZoneIds = [route53HostedZoneId];
            }
            const recordsToCreate = domain.createRoute53IPv6Record ? ["A", "AAAA"] : ["A"];
            for (const hostedZoneId of hostedZoneIds) {
                const changes = recordsToCreate.map((Type) => ({
                    Action: action,
                    ResourceRecordSet: Object.assign({ AliasTarget: {
                            DNSName: domainInfo.domainName,
                            EvaluateTargetHealth: false,
                            HostedZoneId: domainInfo.hostedZoneId,
                        }, Name: domain.givenDomainName, Type }, routingOptions),
                }));
                const params = {
                    ChangeBatch: {
                        Changes: changes,
                        Comment: `Record created by "${globals_1.default.pluginName}"`,
                    },
                    HostedZoneId: hostedZoneId,
                };
                // Make API call
                try {
                    yield (0, utils_1.throttledCall)(this.route53, "changeResourceRecordSets", params);
                }
                catch (err) {
                    throw new Error(`Failed to ${action} ${recordsToCreate.join(",")} Alias for '${domain.givenDomainName}':\n
                    ${err.message}`);
                }
            }
        });
    }
    /**
     * Gets Route53 HostedZoneId from user or from AWS
     */
    getRoute53HostedZoneId(domain, isHostedZonePrivate) {
        return __awaiter(this, void 0, void 0, function* () {
            if (domain.hostedZoneId) {
                globals_1.default.logInfo(`Selected specific hostedZoneId ${domain.hostedZoneId}`);
                return domain.hostedZoneId;
            }
            const isPrivateDefined = typeof isHostedZonePrivate !== "undefined";
            if (isPrivateDefined) {
                const zoneTypeString = isHostedZonePrivate ? "private" : "public";
                globals_1.default.logInfo(`Filtering to only ${zoneTypeString} zones.`);
            }
            let hostedZones = [];
            try {
                hostedZones = yield (0, utils_1.getAWSPagedResults)(this.route53, "listHostedZones", "HostedZones", "Marker", "NextMarker", {});
            }
            catch (err) {
                throw new Error(`Unable to list hosted zones in Route53.\n${err.message}`);
            }
            const targetHostedZone = hostedZones
                .filter((hostedZone) => {
                return !isPrivateDefined || isHostedZonePrivate === hostedZone.Config.PrivateZone;
            })
                .filter((hostedZone) => {
                const hostedZoneName = hostedZone.Name.replace(/\.$/, "");
                return domain.givenDomainName.endsWith(hostedZoneName);
            })
                .sort((zone1, zone2) => zone2.Name.length - zone1.Name.length)
                .shift();
            if (targetHostedZone) {
                return targetHostedZone.Id.replace("/hostedzone/", "");
            }
            else {
                throw new Error(`Could not find hosted zone '${domain.givenDomainName}'`);
            }
        });
    }
}
module.exports = Route53Wrapper;
