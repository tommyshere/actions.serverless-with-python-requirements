"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const globals_1 = require("../globals");
const utils_1 = require("../utils");
const certStatuses = ["PENDING_VALIDATION", "ISSUED", "INACTIVE"];
class ACMWrapper {
    constructor(endpointType) {
        const credentials = globals_1.default.serverless.providers.aws.getCredentials();
        credentials.region = globals_1.default.defaultRegion;
        if (endpointType === globals_1.default.endpointTypes.regional) {
            credentials.region = globals_1.default.serverless.providers.aws.getRegion();
        }
        this.acm = new globals_1.default.serverless.providers.aws.sdk.ACM(credentials);
    }
    /**
     * * Gets Certificate ARN that most closely matches domain name OR given Cert ARN if provided
     */
    getCertArn(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            let certificateArn; // The arn of the selected certificate
            let certificateName = domain.certificateName; // The certificate name
            try {
                const certificates = yield (0, utils_1.getAWSPagedResults)(this.acm, "listCertificates", "CertificateSummaryList", "NextToken", "NextToken", { CertificateStatuses: certStatuses });
                // enhancement idea: weight the choice of cert so longer expiries
                // and RenewalEligibility = ELIGIBLE is more preferable
                if (certificateName != null) {
                    certificateArn = this.getCertArnByCertName(certificates, certificateName);
                }
                else {
                    certificateName = domain.givenDomainName;
                    certificateArn = this.getCertArnByDomainName(certificates, certificateName);
                }
            }
            catch (err) {
                throw Error(`Could not search certificates in Certificate Manager.\n${err.message}`);
            }
            if (certificateArn == null) {
                throw Error(`Could not find an in-date certificate for '${certificateName}'.`);
            }
            return certificateArn;
        });
    }
    /**
     * * Gets Certificate ARN that most closely matches Cert ARN and not expired
     */
    getCertArnByCertName(certificates, certName) {
        const found = certificates.find((c) => c.DomainName === certName);
        if (found) {
            return found.CertificateArn;
        }
        return null;
    }
    /**
     * * Gets Certificate ARN that most closely matches domain name
     */
    getCertArnByDomainName(certificates, domainName) {
        // The more specific name will be the longest
        let nameLength = 0;
        let certificateArn;
        for (const currCert of certificates) {
            const allDomainsForCert = [
                currCert.DomainName,
                ...(currCert.SubjectAlternativeNameSummaries || []),
            ];
            for (const currCertDomain of allDomainsForCert) {
                let certificateListName = currCertDomain;
                // Looks for wild card and take it out when checking
                if (certificateListName[0] === "*") {
                    certificateListName = certificateListName.substring(1);
                }
                // Looks to see if the name in the list is within the given domain
                // Also checks if the name is more specific than previous ones
                if (domainName.includes(certificateListName)
                    && certificateListName.length > nameLength) {
                    nameLength = certificateListName.length;
                    certificateArn = currCert.CertificateArn;
                }
            }
        }
        return certificateArn;
    }
}
module.exports = ACMWrapper;
